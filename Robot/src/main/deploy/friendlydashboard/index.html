<!DOCTYPE html>

<html>
<head>
<title>Friendly Dashboard</title>
<style>
html, body {
    height: 100%;
    margin: 0;
    font-family: monospace;
    background-color: black;
    
    --theme-color-bright: #fcbc34;
    --theme-color-mid: #e43049;
    --theme-color-dark: #6d2624;
    
    --theme-color-gray: #222;
    --theme-color-lime: #0F0;
}

body {
    display: flex;
    flex-direction: column;
}

.button {
    display: inline-block;
    font-size: 1.5em;
    font-weight: bold;
    text-decoration: none;
    text-align: center;
    color: var(--theme-color-gray);
    background-color: var(--theme-color-mid);
    border: var(--theme-color-mid) solid 0.5em;
    border-radius: 1em;
    cursor: pointer;
    opacity: 1;
    transition: opacity 0.5s;
}
.button_spaced {
    margin: 0.5em;
    margin-right: 0;
}
.button_clickEffect {
    opacity: 0.5;
    transition: opacity 0s;
}
.group_unstretched.group_borderless > * + .button {
    margin-top: 0.667em; /* Inverses font-size: 1.5em */
}

#topbar {
    position: sticky;
    top: 0;
    background-color: var(--theme-color-dark);
    color: var(--theme-color-bright);
    border-bottom: var(--theme-color-bright) solid 0.5em;
}
#title_and_status {
    display: inline-block;
    margin-left: 1em;
    margin-top: 0;
    padding-top: 0.67em;
}
#robot_name {
    float: right;
    margin-right: 1em;
    color: var(--theme-color-mid);
}
@media screen and (max-width: 1300px) {
    #title {
        display: none;
    }
}

#main {
    display: flex;
    width: 100%;
    height: 100%;
}
#tabs, #console {
    width: 100%;
    height: 100%;
}

#tabs {
    display: flex;
    flex-direction: column;
    max-width: 66%;
    background-color: var(--theme-color-gray);
    border-right: var(--theme-color-bright) solid 0.5em;
}
#tabs_content {
    height: 0;
    flex-grow: 1;
}
#tabs_selector {
    display: flex;
    background-color: var(--theme-color-dark);
    border-top: var(--theme-color-bright) solid 0.5em;
}
#tabs_selector label {
    width: 100%;
    cursor: pointer;
}
#tabs_selector h2 {
    text-align: center;
    color: black;
}
#tab_widgets_radio:not(:checked) ~ #tabs_content > #tab_widgets,
#tab_table_radio:not(:checked) ~ #tabs_content > #tab_table,
#tab_logs_radio:not(:checked) ~ #tabs_content > #tab_logs {
    display: none;
}
#tab_widgets_radio:checked ~ #tabs_selector #tab_widgets_radio_label h2,
#tab_table_radio:checked ~ #tabs_selector #tab_table_radio_label h2,
#tab_logs_radio:checked ~ #tabs_selector #tab_logs_radio_label h2 {
    color: var(--theme-color-bright);
}

#tab_table {
    display: flex;
    height: 100%;
    white-space: pre;
    overflow: auto;
}
#tab_table > div {
    display: flex;
    flex-direction: column;
    width: 0;
    flex-grow: 1;
}
#tab_table_all {
    border-right: var(--theme-color-bright) solid 0.5em;
}
#tab_table > div > h2 {
    position: relative;
    margin: 0;
    text-align: center;
    color: var(--theme-color-gray);
    background-color: var(--theme-color-mid);
}
#tab_table > div > h2 > label {
    position: absolute;
}
#tab_table_all_active_label {
    left: 0.5em;
}
#tab_table_fav_active_label {
    right: 0.5em;
}
#tab_table_all_active:not(:checked) ~ #tab_table_all {
    display: none;
}
#tab_table_fav_active:not(:checked) ~ #tab_table_fav {
    display: none;
}
#tab_table > div > div {
    display: flex;
    height: 100%;
    overflow: auto;
}
#tab_table table {
    width: 100%;
    height: 0;
}
.graph {
    display: block;
    width: min(100%, 50em);
    height: 25em;
    box-sizing: border-box;
    border: 0.25em solid var(--theme-color-mid);
}


#console {
    flex-shrink: 2;
    display: flex;
    flex-direction: column;
    background-color: black;
}
#console textarea {
    color: var(--theme-color-lime);
}
#console textarea::selection {
    background-color: var(--theme-color-lime);
    color: black;
}
#console_toolbar {
    position: fixed;
    bottom: 1em;
    right: 1em;
}
#console_toolbar img {
    width: 2em;
    height: 2em;
    padding-left: 2em;
    float: right;
    filter: invert(1);
    cursor: pointer;
}
.hidden {
    display: none !important;
}
.active, #packet_protocol_dropdown_open:checked + img {
    filter: invert(1) brightness(0.5) sepia(1) hue-rotate(90deg) saturate(100) !important;
}


textarea.textbox {
    width: 100%;
    height: 100%;
    resize: none;
    padding: 1em;
    box-sizing: border-box;
    border: none;
    outline: none;
    background-color: transparent;
    color: white;
}


table {
    color: white;
    border-collapse: collapse;
}
table thead tr:nth-child(1), table tbody tr:nth-child(even) {
    background-color: black;
}
table td, table th {
    border: white dashed 1px;
}
.checkbox_column {
    width: 1em;
}
table td:has(input[type=checkbox]) {
    max-width: 1em;
}
table td input[type=checkbox] {
    display: block;
    margin: 0;
}


#tab_widgets {
    height: 100%;
}
#tab_widgets > .group {
    width: 100%;
    height: 100%;
}
.group {
    display: flex;
    overflow: auto;
}
.group_vertical {
    flex-direction: column;
}
.group_unstretched.group_borderless {
    margin: 1em;
}
.group_unstretched.group_borderless > * + * {
    margin-top: 1em;
}
.group_stretched > *:not(.size_locked) {
    flex-grow: 1;
}
.group_horizontal.group_stretched > *:not(.size_locked) {
    width: 0;
}
.group_vertical.group_stretched > *:not(.size_locked) {
    height: 0;
}
.group_horizontal.group_bordered > * + * {
    border-left: 0.5em solid var(--theme-color-bright);
}
.group_vertical.group_bordered > * + * {
    border-top: 0.5em solid var(--theme-color-bright);
}
.abstract_selection {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    color: white;
}
.dropdown select {
    flex-grow: 1;
}
.camera {
    display: flex;
    justify-content: center;
    align-items: stretch;
    overflow: hidden;
}
.camera img, .camera canvas {
    max-width: 100%;
    max-height: 100%;
}
.camera_img_not_loaded {
    width: 100%;
    height: 100%;
    background-color: var(--theme-color-gray);
    background-image: url("static.png");
    filter: blur(5px);
}
.camera_popout_message {
    display: flex;
    justify-content: center;
    align-items: center;
}
.camera_popout_message div {
    color: var(--theme-color-bright);
    font-size: 4em;
    text-align: center;
}
.display {
    color: var(--theme-color-mid);
    margin: 0;
    padding: 0.5em;
}
.display pre {
    margin: 0;
}
.display_compact, .display_tiny {
    display: flex;
    align-items: center;
    padding: 0;
}
.display_tiny {
    font-size: 1em;
    color: white;
}
.switch label {
    width: 4em;
    height: 2em;
    cursor: pointer;
    --switch-circle-border: 0.2em;
}
.switch input {
    display: none;
}
.switch span {
    display: block;
    padding: var(--switch-circle-border);
    border-radius: 2em;
    background-color: var(--theme-color-mid);
}
.switch span::before {
    content: "";
    display: block;
    width: calc(2em - var(--switch-circle-border) * 2);
    height: calc(2em - var(--switch-circle-border) * 2);
    border-radius: 2em;
    background-color: var(--theme-color-bright);
    transition: margin-left 0.2s;
}
.switch input:checked + span::before {
    margin-left: 2em;
}
.slider input {
    flex-grow: 1;
}
.connection_indicator {
    display: flex;
    align-items: center;
    color: white;
}
.connection_indicator::before {
    content: "";
    display: inline-block;
    width: 2em;
    height: 2em;
    border-radius: 2em;
    margin-right: 1em;
    background-color: var(--theme-color-mid);
}
.connection_indicator_connected::before {
    background-color: var(--theme-color-lime) !important;
}
.tabs_widget_selector {
    display: flex;
    justify-content: space-around;
}
.tabs_widget_selector text {
    flex-grow: 1;
    font-size: 2em;
    text-align: center;
    color: var(--theme-color-dark);
    cursor: pointer;
}
.tabs_widget_selector > .tabs_widget_selected {
    color: var(--theme-color-bright);
}
.tabs_widget_content > *:not(.tabs_widget_selected) {
    display: none;
}
.tabs_widget_content > .tabs_widget_selected {
    border-top: none !important;
}
.spacer {
    min-width: 1em;
    min-height: 1em;
}


#tab_logs {
    display: flex;
    flex-direction: column;
    height: 100%;
}
#tab_logs_header {
    border-bottom: var(--theme-color-bright) solid 0.5em;
}
#tab_logs_list {
    padding: 0.5em;
    color: white;
    overflow: auto;
}
#tab_logs_list div {
    margin-left: 1em;
}
#tab_logs_list input:not(:checked) + label + div {
    display: none;
}
#tab_logs_list label::before, #tab_logs_list text::before {
    content: "";
    display: inline-block;
    width: 1em;
    height: 1em;
    background-size: 1em;
    margin-right: 0.5em;
    filter: invert(1);
}
#tab_logs_list input:not(:checked) + label::before {
    background-image: url(folder_closed.svg);
}
#tab_logs_list input:checked + label::before {
    background-image: url(folder_open.svg);
}
#tab_logs_list text::before {
    background-image: url(log.svg);
}
#tab_logs_list label, #tab_logs_list text {
    display: block;
    cursor: pointer;
}
#tab_logs_viewer_active:not(:checked) + #tab_logs_viewer {
    display: none;
}
#tab_logs_viewer {
    position: fixed;
    display: flex;
    flex-direction: column;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1;
    color: white;
    background-color: #222D;
}
#tab_logs_viewer_header {
    background-color: var(--theme-color-dark);
    border-bottom: var(--theme-color-bright) solid 0.5em;
}
#tab_logs_viewer_path {
    margin-left: 1em;
    word-wrap: break-word;
}
#tab_logs_viewer_content {
    flex-grow: 1;
    padding: 1em;
    font-size: 1.2em;
    font-weight: bold;
    overflow: auto;
    white-space: pre-wrap;
}
#tab_logs_viewer_footer {
    background-color: var(--theme-color-dark);
    border-top: var(--theme-color-bright) solid 0.5em;
}


#packet_protocol_dropdown {
    position: absolute;
    display: none;
    top: -30px;
}
#packet_protocol_dropdown_open:checked ~ #packet_protocol_dropdown {
    display: block;
}


#topbar_comp_view {
    background-color: var(--theme-color-gray);
    mask-image: url(comp_view.svg);
    -webkit-mask-image: url(comp_view.svg);
    mask-size: contain;
    -webkit-mask-size: contain;
    width: 3em;
    height: 3em;

    float: right;
    margin-right: 2em;
    margin-top: 1em;
    cursor: pointer;
}
#comp_view:checked ~ #topbar > #topbar_comp_view {
    background-color: var(--theme-color-bright);
}
#comp_view:checked ~ #main > #tabs {
    display: flex !important;
    max-width: none;
}
#comp_view:checked ~ #main > #tabs > #tabs_selector {
    display: none;
}
#comp_view:checked ~ #main > #tabs > #tabs_content > #tab_widgets {
    display: flex;
}
#comp_view:checked ~ #main > #tabs > #tabs_content > *:not(#tab_widgets) {
    display: none;
}
#comp_view:checked ~ #main > #console {
    display: none;
}


#context_menu {
    position: absolute;
    background-color: white;
    box-shadow: 0px 0px 10px 0px;
    border-radius: 5px;
    overflow: hidden;
}
#context_menu text {
    display: block;
    padding: 5px;
    cursor: pointer;
}
#context_menu text:hover {
    background-color: var(--theme-color-bright);
}
</style>
<script src="networktablesclients/msgpack/msgpack.js"></script>
<script src="networktablesclients/nt4.js"></script>
</head>
<body onclick="onClick(event)">

<input type="checkbox" id="comp_view" hidden />

<div id="topbar">
    <h1 id="title_and_status">
        <text id="title">Friendly Dashboard:</text>
        <text id="connect_status" title="Connect Status" style="color: var(--theme-color-mid);">Disconnected</text>
        <text id="packet_status" title="Packet Protocol Status" style="color: var(--theme-color-mid);"></text>
    </h1>
    <div id="topbar_comp_view" title="Competition View"></div>
    <h1 id="robot_name"></h1>
</div>

<div id="main">
    <div id="tabs">
        <input type="radio" name="tabs_radio" id="tab_widgets_radio" hidden checked />
        <input type="radio" name="tabs_radio" id="tab_table_radio" hidden />
        <input type="radio" name="tabs_radio" id="tab_logs_radio" hidden />
        <div id="tabs_content">
            <div id="tab_widgets"></div>
            <div id="tab_table">
                <input id="tab_table_all_active" type="checkbox" checked hidden />
                <input id="tab_table_fav_active" type="checkbox" checked hidden />
                <div id="tab_table_all">
                    <h2>All data<label id="tab_table_fav_active_label" for="tab_table_fav_active">&gt;</label></h2>
                    <div>
                        <table>
                            <thead>
                                <tr>
                                    <th class="checkbox_column"></th>
                                    <th>Name</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody id="tab_table_all_content"></tbody>
                        </table>
                    </div>
                </div>
                <div id="tab_table_fav">
                    <h2><label id="tab_table_all_active_label" for="tab_table_all_active">&lt;</label>Favorites</h2>
                    <div>
                        <table>
                            <thead>
                                <tr>
                                    <th class="checkbox_column"></th>
                                    <th>Name</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody id="tab_table_fav_content"></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div id="tab_logs">
                <div id="tab_logs_header">
                    <a class="button button_spaced" href="javascript:loadLogs()" download>Load Logs</a>
                    <a class="button button_spaced" href="logs.zip" download>Download All Logs</a>
                    <a class="button button_spaced" href="javascript:deleteAllLogs()"
                            title="Doesn't delete the in use logs">Delete All Logs</a>
                    <a class="button button_spaced" href="javascript:deleteOldLogs()"
                            title="Deletes logs from other days">Delete Old Logs</a>
                </div>
                <div id="tab_logs_list"></div>
                <input type="checkbox" id="tab_logs_viewer_active" hidden />
                <div id="tab_logs_viewer">
                    <div id="tab_logs_viewer_header">
                        <h1 id="tab_logs_viewer_path"></h1>
                    </div>
                    <div id="tab_logs_viewer_content"></div>
                    <div id="tab_logs_viewer_footer">
                        <label class="button button_spaced" for="tab_logs_viewer_active">Close</label>
                        <a class="button button_spaced" href="javascript:refreshLog()">Refresh</a>
                        <a class="button button_spaced" id="tab_logs_viewer_download" href="javascript:void(0)" download>Download</a>
                        <a class="button button_spaced" href="javascript:deleteLog()">Delete</a>
                    </div>
                </div>
            </div>
        </div>
        <div id="tabs_selector">
            <label for="tab_widgets_radio" id="tab_widgets_radio_label"><h2>Widgets</h2></label>
            <label for="tab_table_radio" id="tab_table_radio_label"><h2>Table</h2></label>
            <label for="tab_logs_radio" id="tab_logs_radio_label"><h2>Logs</h2></label>
        </div>
    </div>
    <div id="console">
        <textarea id="console_content" class="textbox">
[Console]


&gt; </textarea>
        <div id="console_toolbar">
            <img id="console_fullscreen" src="fullscreen.svg" title="Console Fullscreen" />
            <img id="console_debug" src="debug.svg" title="Debug Mode" />
            <label id="console_packet_protocol" for="packet_protocol_dropdown_open">
                <input id="packet_protocol_dropdown_open" type="checkbox" hidden />
                <img src="packet_protocol.svg" title="Packet Protocol" />
                <select id="packet_protocol_dropdown">
                    <option name="Default">Default</option>
                    <option name="WebSocket">WebSocket</option>
                    <option name="NetworkTable">NetworkTable</option>
                </select>
            </label>
            <img id="console_clear" src="clear_console.svg" title="Clear Console" />
        </div>
    </div>
</div>

<div id="context_menu" hidden></div>

<script>
// Converts any data to something safe to use in an id, via a modified base64 encode
// Make sure to append some text before the output, as it may start with a non-letter
function htmlIdEncode(bin) {
    bin = new TextEncoder().encode(bin); // Handle unicode
    bin = Array.from(bin, byte => String.fromCodePoint(byte)).join("");
    return btoa(bin).replaceAll("=", "").replaceAll("+", "-").replaceAll("/", "_");
}

function genNoCacheGETParam() {
    return "?nocache=" + Math.floor(Math.random() * 1000000);
}

// Edited from: https://stackoverflow.com/a/54070620
// input: r,g,b in [0,255], out: h in [0,360) and s,v in [0,1]
function rgb2hsv(r,g,b) {
    if (g === undefined) {
        ([r, g, b] = r);
    }
    r /= 255;
    g /= 255;
    b /= 255;
    let v=Math.max(r,g,b), c=v-Math.min(r,g,b);
    let h= c && ((v==r) ? (g-b)/c : ((v==g) ? 2+(b-r)/c : 4+(r-g)/c));
    return [60*(h<0?h+6:h), v&&c/v, v];
}
// Edited from: https://stackoverflow.com/a/54024653
// input: h in [0,360] and s,v in [0,1] - output: r,g,b in [0,255]
function hsv2rgb(h,s,v) {
    if (s === undefined) {
        ([h, s, v] = h);
    }
    let f= (n,k=(n+h/60)%6) => v - v*s*Math.max( Math.min(k,4-k,1), 0);
    return [f(5)*255,f(3)*255,f(1)*255];
}
class ImageData {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
    }
    poll(source) {
        if (source) {
            this.ctx.drawImage(source, 0, 0, this.canvas.width, this.canvas.height);
        }
        this.data = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        this.pixels = this.data.data;
    }
    write(output) {
        var ctx = this.ctx;
        if (output) {
            ctx = output.getContext("2d");
        }
        ctx.putImageData(this.data, 0, 0);
    }
    getWidth() {
        return this.data.width;
    }
    getHeight() {
        return this.data.height;
    }
    getNumPixels() {
        return this.pixels.length / 4;
    }
    getPixelRGB(x, y) {
        var i = (x + y * this.getWidth()) * 4;
        return this.pixels.slice(i, i + 3);
    }
    getPixelHSV(x, y) {
        return rgb2hsv(this.getPixelRGB(x, y));
    }
    setPixelRGB(x, y, r, g, b) {
        if (g === undefined) {
            ([r, g, b] = r);
        }
        var i = (x + y * this.getWidth()) * 4;
        this.pixels[i] = r;
        this.pixels[i + 1] = g;
        this.pixels[i + 2] = b;
    }
    setPixelHSV(x, y, ...hsv) {
        this.setPixelRGB(x, y, hsv2rgb(...hsv));
    }
}

var baseIP = window.location.hostname.substring(0, window.location.hostname.lastIndexOf("."));
var robotIP = baseIP + ".2";
if (baseIP === "") {
    baseIP = "localhost";
    robotIP = "localhost";
}

var getTime;
{
    let startTime = Date.now();
    getTime = () => {
        return Date.now() - startTime;
    };
}


class Widget {
    constructor(msg) {
        this.id = msg.shift();
        this.sizeLocked = msg.shift();
        this.ntListeners = {};

        widgets.set(this.id, this);
    }
    registerListener(name, listener) {
        if (name instanceof Array) {
            for (var entry of name) {
                this.registerListener(entry, listener);
            }
            return;
        }
        (this.ntListeners[name] ??= []).push(listener);
    }
    notifyListeners(name, value) {
        name = name.split("/");
        var listenersName = "";
        while (name.length > 0) {
            listenersName += name.shift() + (name.length == 0 ? "" : "/");
            var listeners = this.ntListeners[listenersName];
            if (listeners != null) {
                for (var listener of listeners) {
                    listener(value, name);
                }
            }
        }
    }
    build() {
        throw new Error("Widget#build must be implemented!");
    }
    cleanup() {}
    handlePacket(msg) {}
    sendPacket(...payload) {
        var packet = new Uint8Array(msgpack.serialize([this.id, ...payload], {multiple: true}));
        netTables.sendPacket("WidgetD2R", btoa(String.fromCodePoint(...packet))); // To base64
    }
}

class GroupWidget extends Widget {
    static GENERIC_CONTAINER = "group group_vertical group_stretched group_bordered".split(" ");
    constructor(msg) {
        super(msg);
        this.vertical = msg.shift();
        this.stretched = msg.shift();
        this.bordered = msg.shift();
        this.widgets = [];
        for (var i = 0, num = msg.shift(); i < num; i++) {
            this.widgets.push(new (widgetNames[msg.shift()])(msg));
        }
    }
    build() {
        var div = document.createElement("div");
        div.classList.add("group");
        div.classList.add("group_" + (this.vertical ? "vertical" : "horizontal"));
        div.classList.add("group_" + (this.stretched ? "stretched" : "unstretched"));
        div.classList.add("group_" + (this.bordered ? "bordered" : "borderless"));
        for (var widget of this.widgets) {
            var builtWidget = widget.build();
            if (this.stretched && widget.sizeLocked) {
                builtWidget.classList.add("size_locked");
            }
            div.appendChild(builtWidget);
        }
        if (!this.bordered) {
            var wrapper = document.createElement("div");
            wrapper.appendChild(div);
            div = wrapper;
        }
        return div;
    }
}

class AbstractSelectionWidget extends Widget {
    constructor(type, msg) {
        super(msg);
        this.type = type;
        this.name = msg.shift();
        this.path = msg.shift();
        this.registerListener([
            this.path + "/active",
            this.path + "/default",
            this.path + "/options"
        ], () => this.update());
    }
    build() {
        var div = document.createElement("div");
        div.classList.add("abstract_selection");
        div.classList.add(this.type);
        div.appendChild(document.createTextNode(this.name + ":\u00A0"));
        div.appendChild(this.buildInteractable());
        return div;
    }
    update() {
        var selectActive = netTables.entries[this.path + "/active"];
        var selectDefault = netTables.entries[this.path + "/default"];
        var selectOptions = netTables.entries[this.path + "/options"];
        if (selectActive === undefined || selectDefault === undefined || selectOptions === undefined) {
            return;
        }
        selectOptions = JSON.parse(selectOptions);

        this.updateInteractable(selectActive, selectDefault, selectOptions);
    }
    buildInteractable() {
        throw new Error("AbstractSelectionWidget#buildInteractable must be implemented!");
    }
    updateInteractable(selectActive, selectDefault, selectOptions) {
        throw new Error("AbstractSelectionWidget#updateInteractable must be implemented!");
    }
    getSelected() {
        throw new Error("AbstractSelectionWidget#getSelected must be implemented!");
    }
}

class DropdownWidget extends AbstractSelectionWidget {
    constructor(msg) {
        super("dropdown", msg);
    }
    buildInteractable() {
        this.select = document.createElement("select");
        this.select.onchange = () => {
            netTables.setTopicValue(this.path + "/selected", NT4_TYPESTR.STR, this.select.value);
        };
        this.update();

        return this.select;
    }
    updateInteractable(selectActive, selectDefault, selectOptions) {
        var elist_options = [];
        for (var option of selectOptions) {
            var e_option = document.createElement("option");
            e_option.appendChild(document.createTextNode(option));
            e_option.setAttribute("value", option);
            elist_options.push(e_option);
        }
        this.select.replaceChildren(...elist_options);
        this.select.selectedIndex = selectOptions.indexOf(selectActive);
    }
    getSelected() {
        return this.select.value;
    }
}

class FieldWidget extends Widget {
    constructor(msg) {
        super(msg);
        this.name = msg.shift();
        this.fieldYear = msg.shift();
        this.fieldWidthMeters = msg.shift();
        this.fieldHeightMeters = msg.shift();

        netTables.useFastUpdatePeriod("/SmartDashboard/" + this.name + "/");
        this.registerListener("/SmartDashboard/" + this.name + "/", () => this._render());
        this.registerListener("/FMSInfo/IsRedAlliance", () => this._render());

        this.mouseX = -2718;
        this.mouseY = -2718;
    }
    build() {
        this.canvas = document.createElement("canvas");
        this.canvas.classList.add("field");
        this.ctx = this.canvas.getContext("2d");

        this.fieldImg = new Image();
        this.fieldImg.onload = () => this._render();
        this.fieldImg.src = "fields/" + this.fieldYear + ".png";
        
        this.canvas.onmousemove = event => {
            this.mouseX = event.offsetX;
            this.mouseY = event.offsetY;
            this._render();
        };
        this.canvas.onmouseleave = event => {
            this.mouseX = -2718;
            this.mouseY = -2718;
            this._render();
        };
        new ResizeObserver(() => this._render()).observe(this.canvas);
        
        return this.canvas;
    }
    _generateBounds() {
        // Suggest width & height from field img
        this.canvas.width = this.fieldImg.width;
        this.canvas.height = this.fieldImg.height;

        // Get actual width & height and update resolution
        this.fullWidth = this.canvas.offsetWidth;
        this.fullHeight = this.canvas.offsetHeight;
        this.canvas.width = this.fullWidth;
        this.canvas.height = this.fullHeight;

        // Scale field img and center it
        var scaleX = this.fullWidth / this.fieldImg.width;
        var scaleY = this.fullHeight / this.fieldImg.height;
        var scale = Math.min(scaleX, scaleY);

        this.width = scale * this.fieldImg.width;
        this.height = scale * this.fieldImg.height;
        this.x = (this.fullWidth - this.width) / 2;
        this.y = (this.fullHeight - this.height) / 2;
    }
    _render() {
        this._generateBounds();
        this.ctx.clearRect(0, 0, this.fullWidth, this.fullHeight);

        this.ctx.save();
        if (netTables.entries["/FMSInfo/IsRedAlliance"] === "true") {
            this.ctx.translate(this.width / 2, this.height / 2);
            this.ctx.rotate(Math.PI);
            this.ctx.translate(-this.width / 2, -this.height / 2);
        }
        this.ctx.drawImage(this.fieldImg, this.x, this.y, this.width, this.height);
        this.ctx.restore();
        
        for (var entry in netTables.entries) {
            if (!entry.startsWith("/SmartDashboard/" + this.name + "/"))
                continue;
            var objName = entry.substring(("/SmartDashboard/" + this.name + "/").length);
            if (objName.startsWith("."))
                continue;
            
            var isTrajectory = objName.startsWith("[Trajectory] ");
            if (objName === "Robot") {
                this.ctx.fillStyle = "rgb(255, 0, 0)";
                this.ctx.strokeStyle = "rgb(200, 0, 0)";
            } else if (isTrajectory) {
                this.ctx.fillStyle = "rgb(255, 255, 0)";
                this.ctx.strokeStyle = "rgb(200, 200, 0)";
            } else {
                this.ctx.fillStyle = "rgb(0, 255, 0)";
                this.ctx.strokeStyle = "rgb(0, 200, 0)";
            }
            var dataArray = JSON.parse(netTables.entries[entry]);
            if (isTrajectory) {
                this._renderTrajectory(objName.substring("[Trajectory] ".length), dataArray);
            } else {
                this._renderObject(objName, dataArray);
            }
        }
    }
    _renderObject(name, dataArray) {
        this.ctx.lineWidth = 2;
        const circleRadius = 4;
        const lineRadius = 16;

        var numSubObjects = dataArray.length / 3;
        for (var i = 0; i < numSubObjects; i++) {
            var x = this.x + this._metersToPixels(dataArray[i * 3]);
            var y = this.y + this.height - this._metersToPixels(dataArray[i * 3 + 1]);
            var deg = -dataArray[i * 3 + 2];
            var ang = deg * Math.PI / 180;
            var sinValue = Math.sin(ang);
            var cosValue = Math.cos(ang);

            if (Math.pow(x - this.mouseX, 2) + Math.pow(y - this.mouseY, 2) <= Math.pow(lineRadius, 2)) {
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "bottom";
                this.ctx.fillText(name + (numSubObjects == 1 ? "" : " #" + (i + 1)), x, y - lineRadius);
            }

            this.ctx.beginPath();
            this.ctx.moveTo(x - lineRadius * cosValue, y - lineRadius * sinValue);
            this.ctx.lineTo(x + lineRadius * cosValue, y + lineRadius * sinValue);
            this._renderArrow(x + lineRadius * cosValue, y + lineRadius * sinValue, ang);
            this.ctx.stroke();

            this.ctx.beginPath();
            this.ctx.ellipse(x, y, circleRadius, circleRadius, 0, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
    _renderTrajectory(name, dataArray) {
        const hoverRadius = 16;

        this.ctx.beginPath();
        var x, y; // Saves last (x, y)
        var hovering = false;
        for (var i = 0; i < dataArray.length / 3; i++) {
            x = this.x + this._metersToPixels(dataArray[i * 3]);
            y = this.y + this.height - this._metersToPixels(dataArray[i * 3 + 1]);

            if (Math.pow(x - this.mouseX, 2) + Math.pow(y - this.mouseY, 2) <= Math.pow(hoverRadius, 2)) {
                hovering = true;
            }

            if (i == 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }
        var lastDeg = -dataArray[dataArray.length - 1];
        var lastAng = lastDeg * Math.PI / 180;
        this._renderArrow(x, y, lastAng);
        this.ctx.stroke();

        if (hovering) {
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(name, x + hoverRadius * Math.cos(lastAng), y + hoverRadius * Math.sin(lastAng));
        }
    }
    _renderArrow(x, y, ang) {
        const arrowRadius = 8;
        const angShift = Math.PI / 4;
        
        this.ctx.moveTo(x - arrowRadius * Math.cos(ang - angShift), y - arrowRadius * Math.sin(ang - angShift));
        this.ctx.lineTo(x, y);
        this.ctx.lineTo(x - arrowRadius * Math.cos(ang + angShift), y - arrowRadius * Math.sin(ang + angShift));
    }
    _metersToPixels(meters) {
        // Field image shouldn't be stretched, so width / fieldWidthMeters == height / fieldHeightMeters
        return meters / this.fieldWidthMeters * this.width;
    }
}

class CameraWidget extends Widget {
    static resolveURL(url) {
        // Break the url into the ip, ports, and path using RegEx
        var groups = url.match(/([^:|\/]+)(:([0-9]+)(\|([0-9]+))*)*(\/(.*))*/);
        var ip = groups[1];
        var wifiPort = groups[3];
        var tetherPort = groups[5];
        var path = groups[7];

        // Resolve the IPs in the format {##} to 10.44.88.##
        if (ip.startsWith("{")) {
            if (baseIP == "localhost") {
                ip = "localhost";
            } else if (baseIP == "172.22.11") {
                ip = robotIP;
            } else {
                ip = baseIP + "." + ip.substring(1, ip.indexOf("}"));
            }
        }

        // Select the correct port
        var port = wifiPort;
        if (tetherPort !== undefined && baseIP == "172.22.11") {
            port = tetherPort;
        }

        // Re-build the url using the new ip and port
        var output = ip;
        if (port !== undefined) {
            output += ":" + port;
        }
        if (path !== undefined) {
            output += "/" + path;
        }
        return output;
    }
    constructor(msg) {
        super(msg);
        this.ip = CameraWidget.resolveURL(msg.shift());
        this.autoRestart = msg.shift();
        var linkCount = msg.shift();
        this.link = (linkCount > 0 ? CameraWidget.resolveURL(msg.shift()) : null);
        this.altLink = (linkCount > 1 ? CameraWidget.resolveURL(msg.shift()) : null);
        this.fullIp = "http://" + this.ip;
        this.failedCount = 0;
        this.window = window;

        window.addEventListener("beforeunload", () => {
            if (this.window != window) {
                this.window.close();
            }
        });
    }
    build() {
        this.wrapper = document.createElement("div");
        this.wrapper.classList.add("camera");
        this.wrapper.title = this.ip + "\nShift+Click to pop out";

        if (this.link !== null) {
            this.wrapper.style = "cursor: pointer;";
            this.wrapper.title += "\nClick to open http://" + this.link;
            if (this.altLink !== null) {
                this.wrapper.title += "\nAlt+Click to open http://" + this.altLink;
            }
        }
        this.wrapper.onclick = (event) => {
            if (this.window != window) {
                return;
            }
            if (event.shiftKey) {
                var popup = window.open();

                var e_title = document.createElement("title");
                e_title.innerText = this.ip;
                popup.document.head.appendChild(e_title);

                var e_style = document.createElement("style");
                e_style.appendChild(document.createTextNode(`
                head, body {
                    margin: 0;
                    padding: 0;
                }

                .camera {
                    display: flex;
                    justify-content: center;
                    align-items: stretch;
                    overflow: hidden;

                    height: 100%;
                }
                .camera img {
                    max-width: 100%;
                    max-height: 100%;
                }
                .camera_img_not_loaded {
                    width: 100%;
                    height: 100%;
                    background-color: var(--theme-color-gray);
                    background-image: url("static.png");
                    filter: blur(5px);
                }
                `));
                popup.document.head.appendChild(e_style);

                var e_popoutMessage = document.createElement("div");
                e_popoutMessage.innerText = "Camera moved to second window";
                var e_popoutMessageWrapper = document.createElement("div");
                e_popoutMessageWrapper.appendChild(e_popoutMessage);
                e_popoutMessageWrapper.classList.add("camera_popout_message");
                var e_parent = this.wrapper.parentElement;
                e_parent.replaceChild(e_popoutMessageWrapper, this.wrapper);
                
                popup.document.body.appendChild(this.wrapper);
                
                popup.beforeUnloadCallback = () => {
                    e_parent.replaceChild(this.wrapper, e_popoutMessageWrapper);
                    this.window = window;
                };
                var e_script = document.createElement("script");
                e_script.appendChild(document.createTextNode(`
                window.addEventListener("beforeunload", () => {
                    beforeUnloadCallback();
                });
                `));
                popup.document.body.appendChild(e_script);

                this.window = popup;
                return;
            }
            if (this.link !== null) {
                if (this.altLink == null || !event.altKey) {
                    window.open("http://" + this.link);
                } else {
                    window.open("http://" + this.altLink);
                }
            }
        };

        this.loadingImg = document.createElement("div");
        this.loadingImg.classList.add("camera_img_not_loaded");
        this.loadingImg.onclick = () => {
            if (!this.autoRestart) {
                this.actualImg.src = this.fullIp + genNoCacheGETParam();
            }
        };
        this.wrapper.replaceChildren(this.loadingImg);

        if (this.autoRestart) {
            if (!this.autoRestartSetup) {
                this.autoRestartSetup = true;
                this.autoRestartLoop();
            }
        } else {
            this.autoRestartSetup = false;
            this.actualImg = this.window.document.createElement("img");
            this.actualImg.src = this.fullIp + genNoCacheGETParam();
            this.actualImg.onload = () => {
                this.wrapper.replaceChildren(this.actualImg);
            };
            this.actualImg.onerror = () => {
                this.wrapper.replaceChildren(this.loadingImg);
            };
        }

        return this.wrapper;
    }
    autoRestartLoop() {
        if (!widgets.has(this.id)) {
            return;
        }

        var loaded = false;
        var continuedLoop = false;
        var buffer = this.window.document.createElement("img");
        buffer.src = this.fullIp + genNoCacheGETParam();
        buffer.onload = () => {
            loaded = true;
            this.failedCount = 0;
            this.actualImg = buffer;
            this.wrapper.children[0].src = "";
            this.wrapper.replaceChildren(this.actualImg);
            if (!continuedLoop) {
                setTimeout(() => this.autoRestartLoop(), 5000);
            }
        };
        setTimeout(() => {
            if (!loaded) {
                continuedLoop = true;
                this.failedCount++;
                buffer.src = "";
                if (!this.autoRestart || this.failedCount >= 2) {
                    this.wrapper.replaceChildren(this.loadingImg);
                }
                if (this.autoRestart) {
                    this.autoRestartLoop();
                }
            }
        }, 5000);
    }
}

class DisplayWidget extends Widget {
    constructor(msg) {
        super(msg);
        this.value = msg.shift();
        this.size = msg.shift();
        var remaining = this.value;
        var start;
        var end;
        while ((start = remaining.indexOf("{")) != -1 && (end = remaining.indexOf("}")) != -1) {
            var name = remaining.substring(start + 1, end);
            remaining = remaining.substring(end + 1);
            this.registerListener(name, value => this.update());
        }
    }
    build() {
        this.h1 = document.createElement("h1");
        this.h1.classList.add("display");
        if (this.size == 1) {
            this.h1.classList.add("display_compact");
        } else if (this.size == 2) {
            this.h1.classList.add("display_tiny");
        }
        this.pre = document.createElement("pre");
        this.h1.appendChild(this.pre);
        this.update();
        return this.h1;
    }
    update() {
        var newValue = "";
        var remaining = this.value;
        var start;
        var end;
        while ((start = remaining.indexOf("{")) != -1 && (end = remaining.indexOf("}")) != -1) {
            newValue += remaining.substring(0, start);
            var name = remaining.substring(start + 1, end);
            remaining = remaining.substring(end + 1);
            newValue += netTables.entries[name];
        }
        newValue += remaining;
        this.pre.textContent = newValue;
    }
}

class ButtonWidget extends Widget {
    constructor(msg) {
        super(msg);
        this.name = msg.shift();
        this.clickId = 0;
        this.registerListener("/Dashboard/button_" + this.id + "/clickId", value => {
            value = parseInt(value);
            if (value > this.clickId) {
                this.clickId = value;
                this.btn.classList.add("button_clickEffect");
                this.btn.offsetWidth; // Re-calculates CSS, causing the transition to apply
                this.btn.classList.remove("button_clickEffect");
            }
        });
    }
    build() {
        this.btn = document.createElement("text");
        this.btn.classList.add("button");
        this.btn.innerText = this.name;
        this.btn.onclick = () => {
            if (netTables.isPacketProtocolConnected()) {
                this.sendPacket();
            } else {
                netTables.setTopicValue("/SmartDashboard/" + this.name + "/running", NT4_TYPESTR.BOOL, true);
            }
        };
        return this.btn;
    }
}

class SwitchWidget extends AbstractSelectionWidget {
    constructor(msg) {
        super("switch", msg);
    }
    buildInteractable() {
        this.label = document.createElement("label");
        this.input = document.createElement("input");
        this.span = document.createElement("span");

        var id = "switch_" + htmlIdEncode(this.path);
        this.input.setAttribute("id", id);
        this.input.setAttribute("type", "checkbox");
        this.label.setAttribute("for", id);
        this.label.replaceChildren(this.input, this.span);

        this.input.onchange = () => {
            netTables.setTopicValue(this.path + "/selected", NT4_TYPESTR.STR, "" + this.input.checked);
        };
        this.update();

        return this.label;
    }
    updateInteractable(selectActive, selectDefault, selectOptions) {
        if (selectActive === "true") {
            this.input.checked = true;
        } else if (selectActive === "false") {
            this.input.checked = false;
        } else {
            this.input.checked = (selectDefault === "true");
        }
    }
    getSelected() {
        return this.input.checked ? "true" : "false";
    }
}

class GraphWidget extends Widget {
    constructor(msg) {
        super(msg);
        this.name = msg.shift();
        this.path = msg.shift();
    }
    build() {
        this.canvas = document.createElement("canvas");
        this.graph = Graph.forCanvas(this.canvas);
        var render = this.graph.render.bind(this.graph);
        this.graph.render = () => {
            render();
            var ctx = this.graph.ctx;
            ctx.fillStyle = "black";
            ctx.globalAlpha = 0.5;
            var prevFont = ctx.font;
            ctx.font = "bold 50px monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(this.name, this.canvas.width / 2, this.canvas.height / 2);
            ctx.font = prevFont;
            ctx.globalAlpha = 1;
        };
        netTables.registerGraph(this.path, this.graph);
        netTables.useFastUpdatePeriod(this.path);
        return this.canvas;
    }
    cleanup() {
        this.graph.stop();
    }
}

class CheckSelectionsWidget extends Widget {
    constructor(msg) {
        super(msg);
        this.name = msg.shift();
        this.selections = [];
        for (var i = 0, num = msg.shift(); i < num; i++) {
            var widget = widgets.get(msg.shift());
            if (widget === undefined) {
                throw new Error("Could not find widget! Make sure the CheckSelectionsWidget is after all of the referenced widgets");
            }
            this.selections.push(widget);
        }
    }
    build() {
        this.btn = document.createElement("text");
        this.btn.classList.add("button");
        this.btn.innerText = this.name;
        this.btn.onclick = () => {
            this.sendPacket(...this.selections.map(selection => selection.getSelected()));
        };
        return this.btn;
    }
    handlePacket(msg) {
        alert(msg.shift() ? "Settings confirmed!" : "Desync detected! Try reloading!");
    }
}

class SliderWidget extends Widget {
    constructor(msg) {
        super(msg);
        this.name = msg.shift();
        this.defaultValue = msg.shift();
        this.min = msg.shift();
        this.max = msg.shift();
        this.value = this.defaultValue;
    }
    build() {
        this.div = document.createElement("div");
        this.div.classList.add("abstract_selection"); // Re-uses the label css
        this.div.classList.add("slider");
        this.div.appendChild(document.createTextNode(this.name + ":\u00A0"));
        
        this.input = document.createElement("input");
        this.input.setAttribute("type", "range");
        this.input.setAttribute("min", 0);
        this.input.setAttribute("max", 1000);
        this.input.value = (this.defaultValue - this.min) / (this.max - this.min) * 1000;
        this.input.oninput = () => {
            this.value = this.input.value / 1000 * (this.max - this.min) + this.min;
            this.text.innerText = this.value.toFixed(3);
        };
        this.input.onchange = () => {
            netTables.setTopicValue("/Dashboard/slider_" + this.id + "/value", NT4_TYPESTR.FLOAT_64, this.value);
        };
        this.div.appendChild(this.input);

        this.text = document.createElement("text");
        this.text.innerText = this.defaultValue.toFixed(3);
        this.div.appendChild(this.text);

        return this.div;
    }
}

class ConnectionIndicatorWidget extends Widget {
    static TYPE_IP = 0;
    static TYPE_NT_HEARTBEAT = 1;
    static TYPE_NT_BOOLEAN = 2;
    static CHECK_CONNECTION_LOOP_INTERVAL = -1;
    static CHECK_CONNECTION_REQUESTS = [];
    constructor(msg) {
        super(msg);
        this.name = msg.shift();
        this.type = msg.shift();
        if (this.type === ConnectionIndicatorWidget.TYPE_IP) {
            this.ip = CameraWidget.resolveURL(msg.shift());
            this.fullIp = "http://" + this.ip;
            this.failedCount = 0;
        } else {
            this.ntPath = msg.shift();
        }
    }
    build() {
        this.text = document.createElement("text");
        this.text.classList.add("connection_indicator");
        this.text.appendChild(document.createTextNode(this.name));

        // Create a loop that checks the connections of all of the ConnectionIndicatorWidgets if it hasn't been created by another one already
        if (this.ip !== undefined && ConnectionIndicatorWidget.CHECK_CONNECTION_LOOP_INTERVAL == -1) {
            ConnectionIndicatorWidget.CHECK_CONNECTION_LOOP_INTERVAL = setInterval(() => {
                var checkConnWidgets = [...widgets.values()].filter(widget => widget instanceof ConnectionIndicatorWidget);
                if (checkConnWidgets.length == 0) {
                    clearInterval(ConnectionIndicatorWidget.CHECK_CONNECTION_LOOP_INTERVAL);
                } else if (ConnectionIndicatorWidget.CHECK_CONNECTION_REQUESTS.length > 0) {
                    ConnectionIndicatorWidget.CHECK_CONNECTION_REQUESTS.shift()();
                }
            }, 1000);
        }
        this.checkConnectionLoop();

        return this.text;
    }
    checkConnectionLoop() {
        if (!widgets.has(this.id)) {
            return;
        }

        [
            this.checkConnectionsLoop_TYPE_IP,
            this.checkConnectionsLoop_TYPE_NT_HEARTBEAT,
            this.checkConnectionsLoop_TYPE_NT_BOOLEAN
        ][this.type].bind(this)();
    }
    checkConnectionsLoop_TYPE_IP() {
        // Use AJAX to ping the target
        // no-cors mode allows CORS-affected urls to succeed
        ConnectionIndicatorWidget.CHECK_CONNECTION_REQUESTS.push(() => {
            fetch(this.fullIp + genNoCacheGETParam(), {signal: AbortSignal.timeout(1000), mode: "no-cors"})
                    .then(() => {
                        this.failedCount = 0;
                        this.text.classList.add("connection_indicator_connected");
                        this.checkConnectionLoop();
                    })
                    .catch(() => {
                        this.failedCount++;
                        if (this.failedCount == 2) {
                            this.text.classList.remove("connection_indicator_connected");
                        }
                        this.checkConnectionLoop();
                    });
        });
    }
    checkConnectionsLoop_TYPE_NT_HEARTBEAT() {
        var newValue = netTables.entries[this.ntPath];
        if (this.prevNTValue !== newValue) {
            this.lastNTUpdate = Date.now();
            this.text.classList.add("connection_indicator_connected");
        } else if (Date.now() - this.lastNTUpdate > 1000) {
            this.text.classList.remove("connection_indicator_connected");
        }
        this.prevNTValue = newValue;

        setTimeout(() => this.checkConnectionLoop(), 100);
    }
    checkConnectionsLoop_TYPE_NT_BOOLEAN() {
        var value = (netTables.entries[this.ntPath] === "true");
        if (value !== this.text.classList.contains("connection_indicator_connected")) {
            if (value) {
                this.text.classList.add("connection_indicator_connected");
            } else {
                this.text.classList.remove("connection_indicator_connected");
            }
        }

        setTimeout(() => this.checkConnectionLoop(), 100);
    }
}

class TabsWidget extends Widget {
    constructor(msg) {
        super(msg);
        this.tabs = [];
        for (var i = 0, num = msg.shift(); i < num; i++) {
            this.tabs.push({name: msg.shift(), widget: new (widgetNames[msg.shift()])(msg)});
        }
    }
    build() {
        var div = document.createElement("div");
        div.classList.add("tabs_widget");
        div.classList.add(...GroupWidget.GENERIC_CONTAINER);
        
        var e_selector = document.createElement("div");
        e_selector.classList.add("tabs_widget_selector");
        e_selector.classList.add("size_locked");

        var e_content = document.createElement("div");
        e_content.classList.add("tabs_widget_content");
        e_content.classList.add(...GroupWidget.GENERIC_CONTAINER);

        div.replaceChildren(e_selector, e_content);
        
        for (let tab of this.tabs) {
            let e_name = document.createElement("text");
            e_name.textContent = tab.name;
            let e_tabContent = document.createElement("div");
            e_tabContent.classList.add(...GroupWidget.GENERIC_CONTAINER);
            
            e_tabContent.appendChild(tab.widget.build());
            e_name.onclick = () => {
                for (var otherTab of e_selector.children) {
                    otherTab.classList.remove("tabs_widget_selected");
                }
                for (var otherTab of e_content.children) {
                    otherTab.classList.remove("tabs_widget_selected");
                }
                e_name.classList.add("tabs_widget_selected");
                e_tabContent.classList.add("tabs_widget_selected");
            };

            if (e_selector.children.length == 0) {
                e_name.classList.add("tabs_widget_selected");
                e_tabContent.classList.add("tabs_widget_selected");
            }

            e_selector.appendChild(e_name);
            e_content.appendChild(e_tabContent);
        }
        return div;
    }
}

class SpacerWidget extends Widget {
    constructor(msg) {
        super(msg);
    }
    build() {
        var div = document.createElement("div");
        div.classList.add("spacer");
        return div;
    }
}

class ColorRange {
    constructor(msg) {
        this.id = msg.shift();
        this.hueMin = msg.shift();
        this.hueMax = msg.shift();
        this.satMin = msg.shift();
        this.satMax = msg.shift();
        this.valueMin = msg.shift();
        this.valueMax = msg.shift();
        this.signal = false;
    }
    isInRange(hsv) {
        var hueInRange = false;
        if (this.hueMin <= this.hueMax) {
            hueInRange = (this.hueMin <= hsv[0] && hsv[0] <= this.hueMax);
        } else {
            hueInRange = (this.hueMin <= hsv[0] || hsv[0] <= this.hueMax);
        }
        return hueInRange && this.satMin <= hsv[1] && hsv[1] <= this.satMax && this.valueMin <= hsv[2] && hsv[2] <= this.valueMax;
    }
}
class CameraSignalWidget extends Widget {
    constructor(msg) {
        super(msg);
        this.path = msg.shift();
        this.cameraIndex = msg.shift();
        this.crop = msg.shift();
        this.matchingPixelPercent = msg.shift();
        this.colors = [];
        for (var i = 0, numColors = msg.shift(); i < numColors; i++) {
            this.colors.push(new ColorRange(msg));
        }
        this.forcedOff = false;
    }
    build() {
        this.div = document.createElement("div");
        this.div.classList.add("camera");

        var video = document.createElement("video");
        video.setAttribute("hidden", "true");
        this.div.appendChild(video);

        var frame = document.createElement("canvas");
        frame.setAttribute("hidden", "true");
        frame.getContext("2d", {willReadFrequently: true});
        this.div.appendChild(frame);

        var output = document.createElement("canvas");
        var ctx = output.getContext("2d");
        output.setAttribute("title", "Camera #" + this.cameraIndex + "\nClick to force off");
        output.setAttribute("style", "cursor: pointer;");
        output.onclick = () => {
            this.forcedOff = !this.forcedOff;
            if (this.forcedOff) {
                for (var i = 0; i < this.colors.length; i++) {
                    this.colors[i].signal = false;
                    netTables.setTopicValue(this.path + "/" + i, NT4_TYPESTR.BOOL, false);
                }
                output.setAttribute("title", "Camera #" + this.cameraIndex + "\nClick to re-enable");
            } else {
                output.setAttribute("title", "Camera #" + this.cameraIndex + "\nClick to force off");
            }
        };
        this.div.appendChild(output);

        var data = new ImageData(frame);

        var streaming = false;
        video.addEventListener("canplay", event => {
            if (streaming) {
                return;
            }
            
            var width = video.videoWidth;
            var height = video.videoHeight;
            frame.setAttribute("width", width);
            frame.setAttribute("height", height);
            frame.width = width;
            frame.height = height;
            
            output.width = width;
            output.height = height;
            
            streaming = true;
        }, false);

        navigator.mediaDevices.enumerateDevices().then(devices => {
            var videoDevices = [];
            for (var device of devices) {
                if (device.kind == "videoinput") {
                    videoDevices.push(device.deviceId);
                }
            }
            
            navigator.mediaDevices.getUserMedia({video:{deviceId:{exact:videoDevices[this.cameraIndex]}}, audio:false}).then(stream => {
                this.stream = stream;
                video.srcObject = stream;
                video.play();
            }).catch(e => console.error(e));
        });

        var intervalId = setInterval(() => {
            if (!streaming) {
                return;
            }
            if (!widgets.has(this.id)) {
                clearInterval(intervalId);
                return;
            }

            data.poll(video);
            var counts = [];
            for (var color of this.colors) {
                counts.push(0);
            }
            var xStart = (data.getWidth() - data.getWidth() * (1 - this.crop)) / 2;
            var yStart = (data.getHeight() - data.getHeight() * (1 - this.crop)) / 2;
            var xEnd = data.getWidth() - xStart;
            var yEnd = data.getHeight() - yStart;
            for (var x = 0; x < data.getWidth(); x++) {
                for (var y = 0; y < data.getHeight(); y++) {
                    var hsv = data.getPixelHSV(x, y);
                    var matched = false;
                    if (xStart <= x && x <= xEnd && yStart <= y && y <= yEnd) {
                        for (var i = 0; i < this.colors.length; i++) {
                            if (this.colors[i].isInRange(hsv)) {
                                counts[i]++;
                                matched = true;
                            }
                        }
                    }
                    hsv[1] = (matched ? (this.forcedOff ? 0.5 : 1) : 0);
                    data.setPixelHSV(x, y, hsv);
                }
            }
            data.write(output);

            var fontSize = Math.floor(data.getWidth() / 10);
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            ctx.font = fontSize + "px helvetica";
            ctx.fillStyle = (this.forcedOff ? "#AAA" : "#FFF");

            var numSignals = 0;
            for (var i = 0; i < this.colors.length; i++) {
                var newSignal = (counts[i] / ((xEnd - xStart) * (yEnd - yStart)) > this.matchingPixelPercent);

                if (newSignal) {
                    ctx.fillText(this.colors[i].id, 10, 10 + numSignals * fontSize);
                    numSignals++;
                }

                if (!this.forcedOff && this.colors[i].signal != newSignal) {
                    netTables.setTopicValue(this.path + "/" + i, NT4_TYPESTR.BOOL, newSignal);
                    this.colors[i].signal = newSignal;
                }
            }
        }, 16);

        return this.div;
    }
    cleanup() {
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
        }
    }
}

var widgetNames = {
    group: GroupWidget,
    dropdown: DropdownWidget,
    field: FieldWidget,
    camera: CameraWidget,
    display: DisplayWidget,
    button: ButtonWidget,
    switch: SwitchWidget,
    graph: GraphWidget,
    check_selections: CheckSelectionsWidget,
    slider: SliderWidget,
    connection_indicator: ConnectionIndicatorWidget,
    tabs: TabsWidget,
    spacer: SpacerWidget,
    camera_signal: CameraSignalWidget
};

var rootWidget;
var widgets = new Map();

var e_widgets = document.getElementById("tab_widgets");
function updateWidgets(rawMsg) {
    widgets.forEach((widget, id) => widget.cleanup());
    widgets.clear();
    var msg = msgpack.deserialize(rawMsg, {multiple: true});
    rootWidget = new (widgetNames[msg.shift()])(msg);
    e_widgets.replaceChildren(rootWidget.build());
}

var e_tabs = document.getElementById("tabs");
var e_console = document.getElementById("console");
var e_tabTable = document.getElementById("tab_table");
var e_tabTableAllContent = document.getElementById("tab_table_all_content");
var e_tabTableFavContent = document.getElementById("tab_table_fav_content");

var favorites = [];
if (localStorage.favorites) {
    favorites = JSON.parse(localStorage.favorites);
}
function favBoxChanged(event) {
    var key = event.target.parentElement.parentElement.children[1].textContent;
    if (event.target.checked) {
        favorites.push(key);
        localStorage.favorites = JSON.stringify(favorites);
        addTableRow(e_tabTableFavContent, key, netTables.entries[key]);
    } else {
        var i = favorites.indexOf(key);
        if (i != -1) {
            favorites.splice(i, 1);
            localStorage.favorites = JSON.stringify(favorites);
            for (var row of [...e_tabTableAllContent.children]) {
                if (key == row.children[1].textContent) {
                    row.children[0].children[0].checked = false;
                    break;
                }
            }
            removeTableRow(e_tabTableFavContent, key);
        }
    }
}
function addTableRow(tableBody, key, value) {
    function tableData(element) {
        var data = document.createElement("td");
        data.appendChild(element);
        return data;
    }

    var row = document.createElement("tr");
    var favBox = document.createElement("input");
    favBox.setAttribute("type", "checkbox");
    favBox.setAttribute("onchange", "favBoxChanged(event)");
    if (favorites.includes(key))
        favBox.setAttribute("checked", "checked");
    row.appendChild(tableData(favBox));
    row.appendChild(tableData(document.createTextNode(key)));
    var e_value = document.createElement("text");
    e_value.appendChild(document.createTextNode(value));
    row.appendChild(tableData(e_value));

    for (var entry of tableBody.children) {
        if (entry.children[1].textContent.localeCompare(key) > 0) {
            tableBody.insertBefore(row, entry);
            return;
        }
    }
    tableBody.appendChild(row);
}
function removeTableRow(tableBody, key) {
    for (var row of [...tableBody.children]) {
        if (key == row.children[1].textContent) {
            row.remove();
            return true;
        }
    }
    return false;
}
function setTableRow(tableBody, key, value) {
    var selection = window.getSelection();
    var selectionValid = (selection.toString().length > 0);

    for (var row of [...tableBody.children]) {
        if (key == row.children[1].textContent) {
            if (!selectionValid || !selection.containsNode(row, true)) {
                row.children[2].children[0].replaceChildren(document.createTextNode(value));
            }
            return true;
        }
    }
    return false;
}
function addTableRowDataElement(tableBody, key, element) {
    for (var row of [...tableBody.children]) {
        if (key == row.children[1].textContent) {
            row.children[2].appendChild(element);
            return true;
        }
    }
    return false;
}

class Graph {
    static graphs = new WeakMap();
    static forCanvas(canvas) {
        var graph = Graph.graphs.get(canvas);
        if (graph) {
            return graph;
        }
        graph = new Graph(canvas);
        Graph.graphs.set(canvas, graph);
        return graph;
    }
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.values = [];
        this.domainEnd = getTime();
        this.domainLen = 10000;
        this.domainEndLimit = this.domainEnd;
        this.min = null;
        this.max = null;
        this.stopped = false;
        
        new ResizeObserver(() => this.render()).observe(canvas);
        
        this.mouseX = -2718;
        this.mouseY = -2718;
        canvas.onmousemove = (event) => {
            this.mouseX = event.offsetX;
            this.mouseY = event.offsetY;
        };
        canvas.onmouseleave = (event) => {
            this.mouseX = -2718;
            this.mouseY = -2718;
        };

        canvas.onwheel = (event) => {
            event.preventDefault();
            if (event.ctrlKey) {
                // 100 is just a generic speed scalar, unrelated to percent
                var percentDiff = (event.deltaY - event.deltaX) / 100;
                this.domainLen *= (1 + Math.max(-0.5, Math.min(0.5, percentDiff)));
                this.domainLen = Math.max(1, this.domainLen);
            } else {
                var time = getTime();
                this.domainEndLimit = time;
                this.domainEnd = Math.min(this.domainEnd + (event.deltaX + event.deltaY) * this.domainLen / canvas.width, time);
            }
        };

        var dragging = false;
        canvas.addEventListener("mousedown", (event) => {
            if (event.button == 0) {
                dragging = true;
            }
        });
        document.body.addEventListener("mousemove", (event) => {
            if (!(event.buttons & 0b1)) {
                dragging = false;
            }
            if (!dragging) {
                return;
            }
            event.preventDefault();
            if (event.ctrlKey) {
                var offsetX = event.clientX - canvas.getBoundingClientRect().left;
                if (canvas.width - offsetX <= 2) {
                    return;
                }
                this.domainLen += event.movementX * this.domainLen / (canvas.width - offsetX);
                this.domainLen = Math.max(1, this.domainLen);
            } else {
                var time = getTime();
                this.domainEndLimit = time;
                this.domainEnd = Math.min(this.domainEnd - event.movementX * this.domainLen / canvas.width, time);
            }
        });

        var render = () => this.render();
        var isStopped = () => this.stopped;
        requestAnimationFrame(function renderLoop() {
            if (isStopped()) {
                return;
            }
            render();
            requestAnimationFrame(renderLoop);
        });
    }
    addValue(value, time = getTime()) {
        if (value !== null) {
            if (this.min === null) {
                this.min = value - 0.00001;
                this.max = value + 0.00001;
            } else {
                this.min = Math.min(this.min, value);
                this.max = Math.max(this.max, value);
            }
        }
        if (this.values.length == 0 || this.domainEnd >= this.domainEndLimit) {
            this.domainEnd = time;
            this.domainEndLimit = time;
        }
        // Search from the end to the start as the value is most likely near the end
        for (var i = this.values.length; i > 0 && time < this.values[i - 1].time; i--);
        this.values.splice(i, 0, {time: time, value: value});
    }
    stop() {
        this.stopped = true;
    }
    render() {
        this.canvas.width = this.canvas.clientWidth;
        this.canvas.height = this.canvas.clientHeight;
        if (this.canvas.width <= 0 || this.canvas.height <= 0) {
            return;
        }
        
        this.ctx.fillStyle = "white";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        if (this.values.length == 0) {
            return;
        }

        if (this.domainEnd >= this.domainEndLimit) {
            var time = getTime();
            this.domainEnd = time;
            this.domainEndLimit = time;
        }
        
        var domainEnd = this.domainEnd;
        var domainStart = domainEnd - this.domainLen;
        var rangeStart = this.min;
        var rangeEnd = this.max;
        
        // Render grid
        var domainGridSize = this.calcGridSize(domainEnd - domainStart);
        var rangeGridSize = this.calcGridSize(rangeEnd - rangeStart);
        var subDivisions = 5;
        var domainSubGridSize = domainGridSize / subDivisions;
        var rangeSubGridSize = rangeGridSize / subDivisions;

        // Render grid: main
        this.ctx.strokeStyle = getComputedStyle(this.canvas).getPropertyValue("--theme-color-mid");
        for (var time = domainStart - domainStart % domainGridSize; time <= domainEnd; time += domainGridSize) {
            this.ctx.lineWidth = (Math.abs(time) < 0.00001 ? 4 : 1);
            var x = (time - domainStart) / (domainEnd - domainStart) * this.canvas.width;
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }
        for (var value = rangeStart - rangeStart % rangeGridSize; value <= rangeEnd; value += rangeGridSize) {
            this.ctx.lineWidth = (Math.abs(value) < 0.00001 ? 4 : 1);
            var y = (1 - (value - rangeStart) / (rangeEnd - rangeStart)) * this.canvas.height;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }

        // Render grid: sub
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.25;
        var i = 0;
        for (var time = domainStart - domainStart % domainGridSize - domainGridSize; time <= domainEnd; time += domainSubGridSize) {
            if (i++ % subDivisions == 0) {
                continue;
            }
            var x = (time - domainStart) / (domainEnd - domainStart) * this.canvas.width;
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }
        i = 0;
        for (var value = rangeStart - rangeStart % rangeGridSize - rangeGridSize; value <= rangeEnd; value += rangeSubGridSize) {
            if (i++ % subDivisions == 0) {
                continue;
            }
            var y = (1 - (value - rangeStart) / (rangeEnd - rangeStart)) * this.canvas.height;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1;

        // Render line
        this.ctx.strokeStyle = "black";
        this.ctx.lineWidth = 4;
        this.ctx.beginPath();
        var y;
        for (var i = 0; i < this.values.length; i++) {
            var value = this.values[i];
            var prevY = y;
            var x = (value.time - domainStart) / (domainEnd - domainStart) * this.canvas.width;

            if (value.value === null) {
                if (prevY === undefined) {
                    continue;
                }
                this.ctx.lineTo(x, prevY);
                this.ctx.stroke();
                y = undefined;
                prevY = undefined;
                this.ctx.beginPath();
                continue;
            }
            
            y = (1 - (value.value - rangeStart) / (rangeEnd - rangeStart)) * this.canvas.height;
            if (i == 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, prevY);
                this.ctx.lineTo(x, y);
            }
        }
        if (y !== undefined) {
            this.ctx.lineTo(this.canvas.width, y);
        }
        this.ctx.stroke();

        // Render grid labels
        this.ctx.fillStyle = "black";
        this.ctx.textAlign = "left";
        this.ctx.textBaseline = "top";
        for (var time = domainStart - domainStart % domainGridSize; time <= domainEnd; time += domainGridSize) {
            this.ctx.lineWidth = (Math.abs(time) < 0.00001 ? 4 : 1);
            var x = (time - domainStart) / (domainEnd - domainStart) * this.canvas.width;
            this.ctx.save();
            this.ctx.translate(x + 1, this.canvas.height - 1);
            this.ctx.rotate(-Math.PI / 2);
            this.ctx.fillText((time / 1000).toLocaleString(undefined, {maximumFractionDigits: 5}), 0, 0);
            this.ctx.restore();
        }
        this.ctx.textBaseline = "bottom";
        for (var value = rangeStart - rangeStart % rangeGridSize; value <= rangeEnd; value += rangeGridSize) {
            this.ctx.lineWidth = (Math.abs(value) < 0.00001 ? 4 : 1);
            var y = (1 - (value - rangeStart) / (rangeEnd - rangeStart)) * this.canvas.height;
            this.ctx.fillText(value.toLocaleString(undefined, {maximumFractionDigits: 5}), 1, y);
        }

        // Render hovered value
        if (this.mouseX >= 0) {
            var hoveredTime = this.mouseX / this.canvas.width * (domainEnd - domainStart) + domainStart;
            var hoveredValue = null;
            for (var value of this.values) {
                if (hoveredTime >= value.time) {
                    hoveredValue = value.value;
                } else {
                    break;
                }
            }
            if (hoveredValue !== null) {
                var y = (1 - (hoveredValue - rangeStart) / (rangeEnd - rangeStart)) * this.canvas.height;
                var abovePoint = (y > this.canvas.height - 25);
                var leftOfPoint = (this.mouseX > this.canvas.width - 200);
                var text = "(" + (hoveredTime / 1000.0).toLocaleString(undefined, {maximumFractionDigits: 5}) +
                        ", " + hoveredValue.toLocaleString(undefined, {maximumFractionDigits: 5}) + ")";

                // Text background
                var prevFont = this.ctx.font;
                this.ctx.font = "15px monospace";
                this.ctx.fillStyle = "black";
                this.ctx.globalAlpha = 0.5;
                var textWidth = this.ctx.measureText(text).width;
                this.ctx.fillRect(this.mouseX + (leftOfPoint ? -(textWidth + 6) : 2), y + (abovePoint ? -21 : 2), textWidth + 4, 17);
                this.ctx.globalAlpha = 1;

                // Point
                this.ctx.fillStyle = getComputedStyle(this.canvas).getPropertyValue("--theme-color-bright");
                this.ctx.beginPath();
                this.ctx.ellipse(this.mouseX, y, 4, 4, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Text
                this.ctx.textAlign = leftOfPoint ? "right" : "left";
                this.ctx.textBaseline = abovePoint ? "bottom" : "top";
                this.ctx.fillText(text, this.mouseX + (leftOfPoint ? -1 : 1) * 4, y + (abovePoint ? -1 : 1) * 4);
                this.ctx.font = prevFont;
            }
        }
    }
    // From https://stackoverflow.com/a/545960
    calcGridSize(range) {
        var approxGridSize = range / 5;
        var mag = Math.pow(10, Math.floor(Math.log10(approxGridSize)));
        var gridSize = Math.floor(approxGridSize / mag + 0.5);
        if (gridSize > 5) {
            gridSize = 10;
        } else if (gridSize > 2) {
            gridSize = 5;
        } else if (gridSize > 1) {
            gridSize = 2;
        }
        return gridSize * mag;
    }
}

function updateDebugModeWidget() {
    var prevDebug = e_debug.classList.contains("active");
    var newDebug = (netTables.entries["/Dashboard/DebugMode"] === "true");
    if (prevDebug == newDebug) {
        return;
    }
    if (prevDebug) {
        e_debug.classList.remove("active");
    } else {
        e_debug.classList.add("active");
    }
}


delete localStorage.data_switch_checked; // Cleanup old tab selector
for (let tab of ["widgets", "table", "logs"]) {
    document.getElementById("tab_" + tab + "_radio").onclick = () => {
        localStorage.tab = tab;
    };
}
if (localStorage.tab !== undefined && ["widgets", "table", "logs"].includes(localStorage.tab)) {
    document.getElementById("tab_" + localStorage.tab + "_radio").checked = true;
}

var consoleMsg = "[Console]\n\n";
var consoleCmdSpacing = "\n> ";
var consoleCmd = "";
var e_consoleContent = document.getElementById("console_content");
e_consoleContent.oninput = () => {
    if (e_consoleContent.value.startsWith(consoleMsg + consoleCmdSpacing)) {
        consoleCmd = e_consoleContent.value.substring(consoleMsg.length + consoleCmdSpacing.length);
        if (consoleCmd.endsWith("\n")) {
            consoleCmd = consoleCmd.substring(0, consoleCmd.length - 1).replaceAll("_", " ");
            netTables.sendPacket("ConsoleAction", consoleCmd);
            consoleMsg += consoleCmdSpacing + consoleCmd + "\n";
            consoleCmd = "";
        } else {
            return;
        }
    }
    e_consoleContent.value = consoleMsg + consoleCmdSpacing + consoleCmd;
};
e_consoleContent.onkeydown = (event) => {
    if (event.keyCode == 35) { // End
        e_consoleContent.value += "\n";
        e_consoleContent.oninput();
    }
};

var e_fullscreen = document.getElementById("console_fullscreen");
e_fullscreen.onclick = () => {
    if (e_fullscreen.classList.contains("active")) {
        e_fullscreen.classList.remove("active");
        e_tabs.classList.remove("hidden");
    } else {
        e_fullscreen.classList.add("active");
        e_tabs.classList.add("hidden");
    }
};

var e_debug = document.getElementById("console_debug");
e_debug.onclick = () => {
    if (e_debug.classList.contains("active")) {
        e_debug.classList.remove("active");
        netTables.setTopicValue("/Dashboard/DebugMode", NT4_TYPESTR.BOOL, false, true);
    } else {
        e_debug.classList.add("active");
        netTables.setTopicValue("/Dashboard/DebugMode", NT4_TYPESTR.BOOL, true, true);
    }
};

var e_packetProtocol = document.getElementById("console_packet_protocol");
var e_packetProtocolDropdownOpen = document.getElementById("packet_protocol_dropdown_open");
var e_packetProtocolDropdown = document.getElementById("packet_protocol_dropdown");
function onClick(event) {
    if (!e_packetProtocol.contains(event.target)) {
        e_packetProtocolDropdownOpen.checked = false;
    }
}
e_packetProtocolDropdown.onchange = () => {
    if (e_packetProtocolDropdown.value == "Default") {
        netTables.setPacketProtocolToDefault();
    } else {
        netTables.setPacketProtocol(e_packetProtocolDropdown.value);
    }
};

var e_consoleClear = document.getElementById("console_clear");
e_consoleClear.onclick = () => {
    consoleMsg = "[Console]\n\n";
    e_consoleContent.value = consoleMsg + consoleCmdSpacing + consoleCmd;
};

var e_compViewBtn = document.getElementById("topbar_comp_view");
var e_compView = document.getElementById("comp_view");
e_compViewBtn.onclick = () => {
    e_compView.checked = !e_compView.checked;
    if (e_compView.checked) {
        document.body.requestFullscreen();
    } else {
        document.exitFullscreen();
    }
};
document.onfullscreenchange = () => {
    if (!document.fullscreenElement) {
        e_compView.checked = false;
    }
};


var e_connectStatus = document.getElementById("connect_status");
var e_packetStatus = document.getElementById("packet_status");
function updateConnectStatus() {
    if (netTables.connected) {
        if (netTables.ready) {
            e_connectStatus.setAttribute("style", "color: var(--theme-color-lime);");
            e_connectStatus.textContent = "Connected";
            if (netTables.getPacketProtocolName() == null) {
                e_packetStatus.setAttribute("style", "color: var(--theme-color-mid);");
                e_packetStatus.textContent = "[No Packet Protocol]";
            } else {
                if (netTables.isPacketProtocolConnected()) {
                    e_packetStatus.setAttribute("style", "color: var(--theme-color-lime);");
                } else {
                    e_packetStatus.setAttribute("style", "color: var(--theme-color-bright);");
                }
                e_packetStatus.textContent = "[" + netTables.getPacketProtocolName()
                        + (netTables.isPacketProtocolConnected() ? "" : " | Disconnected") + "]";
            }
        } else {
            e_connectStatus.setAttribute("style", "color: var(--theme-color-bright);");
            e_connectStatus.textContent = "Initializing ...";
            e_packetStatus.textContent = "";
        }
    } else {
        e_connectStatus.setAttribute("style", "color: var(--theme-color-mid);");
        e_connectStatus.textContent = "Disconnected";
        e_packetStatus.textContent = "";
    }
}


var LogCodes = {
    LOAD: "L",
    VIEW: "V",
    DELETE: "D"
};
var e_tabLogsList = document.getElementById("tab_logs_list");
var e_tabLogsViewerContent = document.getElementById("tab_logs_viewer_content");
var e_tabLogsViewerPath = document.getElementById("tab_logs_viewer_path");
var e_tabLogsViewerDownload = document.getElementById("tab_logs_viewer_download");
var e_tabLogsViewerActive = document.getElementById("tab_logs_viewer_active");
function loadLogs() {
    netTables.sendPacket("Logs", LogCodes.LOAD);
}
function addFolder(path, files, e_folder) {
    var parentSuffix = "";

    for (let {name: file, value} of files) {
        if (value === 0) {
            var e_name = document.createElement("text");
            e_name.setAttribute("id", "file_" + htmlIdEncode(path + file));
            e_name.appendChild(document.createTextNode(file));
            e_name.onclick = () => {
                netTables.sendPacket("Logs", LogCodes.VIEW + path + file);
            };
            e_folder.appendChild(e_name);

            if (file.endsWith(".matchtype")) {
                parentSuffix += " (" + file.substring(0, file.length - ".matchtype".length) + ")";
            }
            if (file.endsWith(".timestamp")) {
                var time = file.substring(0, file.length - ".timestamp".length);
                var timeInt = parseInt(time);
                if (!isNaN(timeInt)) {
                    var isoTime = new Date(timeInt - new Date().getTimezoneOffset() * 60000).toISOString();
                    time = isoTime.substring(0, isoTime.length - "Z".length).replace("T", " ").replaceAll(":", "-").replaceAll(".", "-");
                }
                parentSuffix += " (" + time + ")";
            }
        } else {
            var id = "folder_" + htmlIdEncode(path + file);

            var open = document.getElementById(id)?.checked;
            var e_checkbox = document.createElement("input");
            e_checkbox.setAttribute("type", "checkbox");
            e_checkbox.setAttribute("id", id);
            e_checkbox.setAttribute("hidden", "");
            if (open) {
                e_checkbox.setAttribute("checked", "");
            }
            e_folder.appendChild(e_checkbox);

            var e_name = document.createElement("label");
            e_name.setAttribute("for", id);
            e_folder.appendChild(e_name);

            var e_div = document.createElement("div");
            var suffix = addFolder(path + file + "/", value, e_div);
            e_name.appendChild(document.createTextNode(file + suffix));
            e_folder.appendChild(e_div);
        }
    }

    return parentSuffix;
}
function deleteAllLogs() {
    if (!confirm("Are you sure you want to delete all logs?"))
        return;
    netTables.sendPacket("Logs", LogCodes.DELETE);
}
function deleteOldLogs() {
    if (!confirm("Are you sure you want to delete old logs?"))
        return;
    netTables.sendPacket("Logs", LogCodes.DELETE + "\0");
}
function refreshLog() {
    netTables.sendPacket("Logs", LogCodes.VIEW + e_tabLogsViewerPath.innerText);
}
function deleteLog() {
    var path = e_tabLogsViewerPath.innerText;
    if (!confirm("Are you sure you want delete '" + path + "'?"))
        return;
    netTables.sendPacket("Logs", LogCodes.DELETE + path);
}


var e_contextMenu = document.getElementById("context_menu");
function openContextMenu(event, options, callback) {
    if (event.shiftKey) {
        return;
    }
    event.preventDefault();
    var e_options = [];
    for (let option of options) {
        let e_option = document.createElement("text");
        e_option.textContent = option;
        e_option.onclick = () => callback(option);
        e_options.push(e_option);
    }
    e_contextMenu.replaceChildren(...e_options);
    e_contextMenu.style.top = event.clientY + "px";
    e_contextMenu.style.left = event.clientX + "px";
    e_contextMenu.removeAttribute("hidden");
}
e_tabTable.oncontextmenu = (event) => {
    var target = event.target;
    if (target.parentElement.tagName.toLowerCase() == "td") {
        target = event.target.parentElement;
    }
    if (target.tagName.toLowerCase() == "td") {
        var name = target.parentElement.children[1].textContent;
        var e_value = target.parentElement.children[2];
        var options = ["Set Update Period"];
        if (netTables.connected) {
            options.unshift("Edit");
        }
        if (["boolean", "int", "float", "double"].includes(netTables.topics[name].type)) {
            options.push("Graph");
        }
        openContextMenu(event, options, option => {
            switch (option) {
                case "Edit":
                    if (name.startsWith("/Dashboard/")) {
                        if (!confirm("Editing '/Dashboard/' values could break the dashboard! Only modify if you know what you're doing. Are you sure?"))
                            break;
                    }
                    var value = prompt("Enter new value for '" + name + "':", netTables.entries[name]);
                    if (value != null) {
                        function toBoolean(value) {
                            if (value.toLowerCase() == "true") {
                                return true;
                            } else if (value.toLowerCase() == "false") {
                                return false;
                            } else {
                                return null;
                            }
                        }
                        function toInt(value) {
                            value = parseInt(value);
                            return (isNaN(value) ? null : value);
                        }
                        function toFloat(value) {
                            value = parseFloat(value);
                            return (isNaN(value) ? null : value);
                        }
                        function toString(value) {
                            return value;
                        }
                        function toJSON(value) {
                            try {
                                JSON.parse(value);
                                return value;
                            } catch (e) {
                                return null;
                            }
                        }
                        function toArray(value, parser) {
                            try {
                                value = JSON.parse(value);
                            } catch (e) {
                                return null;
                            }
                            if (!(value instanceof Array)) {
                                return null;
                            }
                            for (var i = 0; i < value.length; i++) {
                                var element = value[i].toString();
                                element = parser(element);
                                if (element == null) {
                                    return null;
                                }
                                value[i] = element;
                            }
                            return value;
                        }
                        const toTypeMap = {
                            "boolean": toBoolean,
                            "int": toInt,
                            "float": toFloat,
                            "double": toFloat,
                            "string": toString,
                            "json": toJSON,
                            "boolean[]": value => toArray(value, toBoolean),
                            "int[]": value => toArray(value, toInt),
                            "float[]": value => toArray(value, toFloat),
                            "double[]": value => toArray(value, toFloat),
                            "string[]": value => toArray(value, toString)
                        };

                        var type = netTables.topics[name].type;
                        var toType = toTypeMap[type];
                        if (toType) {
                            value = toType(value);
                            if (value == null) {
                                alert("Invalid value for type '" + type + "'");
                            } else {
                                netTables.setTopicValue(name, type, value);
                            }
                        } else {
                            alert("Cannot modify unsupported type '" + type + "'");
                        }
                    }
                    break;
                case "Set Update Period":
                    var period = prompt("Enter update period: (ms)", netTables.fastUpdatePeriod);
                    if (period != null) {
                        period = Math.max(1, Math.min(netTables.updatePeriod, period));
                        netTables.useCustomUpdatePeriod(name, period, true);
                    }
                    break;
                case "Graph":
                    var canvas = e_value.getElementsByClassName("graph")[0];
                    if (canvas) {
                        canvas.remove();
                        var graph = Graph.forCanvas(canvas);
                        graph.stop();
                        netTables.unregisterGraph(name, graph);
                    } else {
                        canvas = document.createElement("canvas");
                        canvas.classList.add("graph");
                        e_value.appendChild(canvas);
                        var graph = Graph.forCanvas(canvas);
                        if (netTables.topics[name].type === "boolean") {
                            graph.min = 0;
                            graph.max = 1;
                            graph.addValue(netTables.entries[name] == "true" ? 1 : 0);
                        } else {
                            graph.addValue(parseFloat(netTables.entries[name]));
                        }
                        var location = e_tabTableAllContent.contains(target) ?
                                NetworkTablesHandler.GRAPH_LOCATION_TABLE_ALL :
                                NetworkTablesHandler.GRAPH_LOCATION_TABLE_FAV;
                        netTables.registerGraph(name, graph, location);
                        netTables.useFastUpdatePeriod(name);
                    }
                    break;
            }
        });
    }
};
document.onclick = document.oncontextmenu = (event) => {
    if (!event.defaultPrevented) { // If something didn't show a new context menu
        e_contextMenu.setAttribute("hidden", "true");
    }
};


class NetworkTablesHandler {
    static GRAPH_LOCATION_OTHER = 0;
    static GRAPH_LOCATION_TABLE_ALL = 1;
    static GRAPH_LOCATION_TABLE_FAV = 2;
    constructor(updatePeriod, fastUpdatePeriod) {
        this.updatePeriod = updatePeriod;
        this.fastUpdatePeriod = fastUpdatePeriod;
        this.subs = [];
        this.entries = {};
        this.topics = {};
        this.graphs = {};
        this.packetProtocol = null;
        this.defaultPacketProtocol = null;
        this.packetListeners = {};
        this.connected = false;
        this.ready = false;
        this.ntClient = new NT4_Client(
            robotIP,
            this.onTopicAdded.bind(this),
            this.onTopicRemoved.bind(this),
            this.onTopicUpdated.bind(this),
            this.onConnected.bind(this),
            this.onDisconnected.bind(this));
    }
    onConnected() {
        // Clear previous data
        this.entries = {};
        this.topics = {};
        this.newTopics = {};
        e_tabTableAllContent.replaceChildren();
        e_tabTableFavContent.replaceChildren();

        // Listen to new data
        if (this.subs.length == 0) {
            this.subs.push(this.ntClient.subscribePeriodic(["/"], this.updatePeriod / 1000.0));
            this.subs.push(this.ntClient.subscribeAllSamples(["/Dashboard/Packets/"]));
        }

        this.defaultPacketProtocol = null;
        this.connected = true;
        updateConnectStatus();
    }
    onDisconnected() {
        // Don't clear entries until reconnect, as the network tables data is still useful
        this.connected = false;
        this.ready = false;
        updateConnectStatus();

        for (var graphs of Object.values(this.graphs)) {
            for (var graph of graphs) {
                graph.graph.addValue(null, getTime());
            }
        }
    }
    onTopicAdded(topic) {
        if (topic.name == "/Dashboard/Widgets") {
            return;
        }

        this.topics[topic.name] = topic;
        addTableRow(e_tabTableAllContent, topic.name, "Loading ...");
        if (favorites.includes(topic.name)) {
            addTableRow(e_tabTableFavContent, topic.name, "Loading ...");
        }
        var value = this.newTopics[topic.name];
        if (value !== undefined) {
            var timestamp = this.ntClient.getServerTime_us();
            this.ntClient.addSample(topic, timestamp, value);
            this.onTopicUpdated(topic, timestamp, value);
        }
        if (topic.name == "/Dashboard/Ready") {
            this.ready = true;
            updateConnectStatus();
        }

        var graphs = this.graphs[topic.name];
        if (graphs) {
            for (var graph of graphs) {
                if (graph.location == NetworkTablesHandler.GRAPH_LOCATION_OTHER) {
                    continue;
                }
                var e_table = (graph.location == NetworkTablesHandler.GRAPH_LOCATION_TABLE_ALL ? e_tabTableAllContent : e_tabTableFavContent);
                addTableRowDataElement(e_table, topic.name, graph.graph.canvas);
            }
        }
    }
    onTopicRemoved(topic) {
        if (topic.name == "/Dashboard/Widgets") {
            return;
        }

        delete this.entries[topic.name];
        delete this.topics[topic.name];
        removeTableRow(e_tabTableAllContent, topic.name);
        if (favorites.includes(topic.name)) {
            removeTableRow(e_tabTableFavContent, topic.name);
        }

        var graphs = this.graphs[topic.name];
        if (graphs) {
            for (var graph of graphs) {
                graph.graph.addValue(null, getTime());
            }
        }
    }
    onTopicUpdated(topic, timestamp, value) {
        if (topic.name == "/Dashboard/Widgets") {
            updateWidgets(value);
            return;
        }
        if (topic.name.startsWith("/Dashboard/Packets/")) {
            this.packetProtocol?.onNTPacket(topic.name, value);
        }
        if (["boolean", "int", "float", "double"].includes(topic.type)) {
            var graphs = this.graphs[topic.name];
            if (graphs) {
                var graphValue = (topic.type == "boolean" ? (value ? 1 : 0) : value);
                for (var i = 0; i < graphs.length; i++) {
                    graphs[i].graph.addValue(graphValue, getTime() + (timestamp - this.ntClient.getServerTime_us()) / 1000);
                }
            }
        }

        value = (value instanceof Object ? JSON.stringify(value) : value.toString());
        if (this.entries[topic.name] == value) {
            return;
        }
        this.entries[topic.name] = value;
        setTableRow(e_tabTableAllContent, topic.name, value);
        if (favorites.includes(topic.name)) {
            setTableRow(e_tabTableFavContent, topic.name, value);
        }

        if (topic.name == "/Dashboard/Ready") {
            this.ready = (value === "true");
            updateConnectStatus();
        } else if (topic.name == "/Dashboard/PacketProtocol") {
            if (this.defaultPacketProtocol == null) {
                this.defaultPacketProtocol = value;
            }
            if (this.packetProtocol == null || this.packetProtocol.getName() != value) {
                if (this.packetProtocol != null) {
                    this.packetProtocol.close();
                }
                this.packetProtocol = packetProtocols[value] ?? null;
                if (this.packetProtocol != null) {
                    this.packetProtocol = this.packetProtocol();
                }
                updateConnectStatus();
            }
            if (e_packetProtocolDropdown.value != "Default") {
                this.requestedPacketProtocol = e_packetProtocolDropdown.value;
            }
            if (this.requestedPacketProtocol != undefined && this.requestedPacketProtocol != value) {
                this.setPacketProtocol(this.requestedPacketProtocol);
            }
        } else if (topic.name == "/Dashboard/DebugMode") {
            updateDebugModeWidget();
        } else if (topic.name == "/SmartDashboard/Selected Robot" ||
                topic.name == "/SmartDashboard/GIT_SHA" ||
                topic.name == "/SmartDashboard/GIT_BRANCH") {
            var robotName = this.entries["/SmartDashboard/Selected Robot"];
            var gitSha = this.entries["/SmartDashboard/GIT_SHA"];
            var gitBranch = this.entries["/SmartDashboard/GIT_BRANCH"];
            if (robotName && gitSha && gitBranch) {
                document.getElementById("robot_name").replaceChildren(document.createTextNode(
                    robotName + " (" + (gitBranch == "HEAD" ? "" : gitBranch + ": ") + gitSha.substring(0, 8) + ")"));
            }
        }
        widgets.forEach(widget => widget.notifyListeners(topic.name, value));
    }
    registerGraph(name, graph, location = NetworkTablesHandler.GRAPH_LOCATION_OTHER) {
        (this.graphs[name] ??= []).push({graph: graph, location: location});
    }
    unregisterGraph(name, graph) {
        var graphs = this.graphs[name];
        if (!graphs) {
            return false;
        }
        for (var i = 0; i < graphs.length; i++) {
            if (graphs[i].graph === graph) {
                graphs.splice(i, 1);
                return true;
            }
        }
        return false;
    }
    useCustomUpdatePeriod(name, period, overwriteFaster = false) {
        // Remove old custom period subscriber
        for (var i = this.subs.length - 1; i >= 0; i--) {
            var topics = this.subs[i].topics;
            if (topics.size == 1 && topics.has(name)) {
                var sub = this.subs[i];
                if (overwriteFaster || !sub.options.all && period / 1000.0 < sub.options.periodicRate_s) {
                    this.ntClient.unSubscribe(sub);
                    this.subs.splice(i, 1);
                    break;
                } else {
                    return;
                }
            }
        }
        
        // Add new subscriber
        this.subs.push(this.ntClient.subscribePeriodic([name], period / 1000.0));
    }
    useFastUpdatePeriod(name, overwriteFaster = false) {
        this.useCustomUpdatePeriod(name, this.fastUpdatePeriod, overwriteFaster);
    }
    setTopicValue(name, type, value, retained = false) {
        var topic = this.topics[name];
        if (!topic) {
            this.newTopics[name] = value;
            topic = this.ntClient.publishNewTopic(name, type);
            if (retained) {
                this.ntClient.setProperties(topic, false, true);
            }
        } else {
            if (topic.pubuid == 0) {
                this.ntClient.publishTopic(topic);
            }
            var timestamp = this.ntClient.getServerTime_us();
            this.ntClient.addSample(topic, timestamp, value);
            this.onTopicUpdated(topic, timestamp, value);
        }
    }

    setPacketProtocol(protocol) {
        if (!this.isPacketProtocolConnected()) {
            this.requestedPacketProtocol = protocol;
            return;
        }
        if (this.packetProtocol.getName() == protocol) {
            return;
        }
        this.requestedPacketProtocol = null;
        this.packetProtocol.sendPacket("SetPacketProtocol", protocol);
    }
    setPacketProtocolToDefault() {
        if (this.defaultPacketProtocol == null) {
            this.requestedPacketProtocol = null;
        } else {
            this.setPacketProtocol(this.defaultPacketProtocol);
        }
    }
    getPacketProtocolName() {
        if (this.packetProtocol == null) {
            return null;
        }
        return this.packetProtocol.getName();
    }
    isPacketProtocolConnected() {
        if (this.packetProtocol == null) {
            return false;
        }
        return this.packetProtocol.isConnected(this);
    }
    addPacketListener(name, listener) {
        (this.packetListeners[name] ??= []).push(listener);
    }
    receivePacket(name, value) {
        var listeners = this.packetListeners[name];
        if (listeners) {
            for (var listener of listeners) {
                listener(value);
            }
        }
    }
    sendPacket(name, value) {
        if (this.packetProtocol != null) {
            return this.packetProtocol.sendPacket(name, value);
        }
        console.warn("Attempted to send packet '" + name + "' without a protocol!");
    }
}

class PacketProtocol {
    getName() {
        throw new Error("Must be implemented");
    }
    isConnected(netTables) {
        throw new Error("Must be implemented");
    }
    onNTPacket(name, value) {}
    sendPacket(name, value) {
        throw new Error("Must be implemented");
    }
    close() {}
}

class NetworkTablePacketProtocol extends PacketProtocol {
    constructor() {
        super();
        this.randNames = {};
    }
    getName() {
        return "NetworkTable";
    }
    isConnected(netTables) {
        return netTables.connected;
    }
    onNTPacket(name, value) {
        netTables.receivePacket(name.substring(name.indexOf(":") + 1), value.substring(value.indexOf(":") + 1));
    }
    sendPacket(name, value) {
        netTables.setTopicValue("/Dashboard/Packets/" + (this.randNames[name] ??= this._genRandHex() + ":" + name), NT4_TYPESTR.STR, this._genRandHex() + ":" + value);
    }
    _genRandHex() {
        return Math.floor(Math.random() * 2**32).toString(16);
    }
}

class WebSocketPacketProtocol extends PacketProtocol {
    static types = ["unassigned", "boolean", "double", "string", "raw",
            "boolean[]", "double[]", "string[]", "integer", "float", "integer[]", "float[]"];
    constructor(...ports) {
        super();
        this.ports = ports;
        this.closed = false;
        this._initSocket(0);
    }
    _initSocket(portIndex) {
        this.socket = new WebSocket("ws://" + robotIP + ":" + this.ports[portIndex]);
        this.socket.binaryType = "arraybuffer";
        this.socket.addEventListener("open", event => {
            this.connected = true;
            updateConnectStatus();
        });
        this.socket.addEventListener("close", event => {
            this.connected = false;
            updateConnectStatus();
            if (!this.closed) {
                this._initSocket((portIndex + 1) % this.ports.length);
            }
        });
        this.socket.addEventListener("message", event => {
            var packet = msgpack.deserialize(new Uint8Array(event.data), {multiple: true});
            var name = packet[0];
            var value = packet[1];
            netTables.receivePacket(name, value);
        });
        this.socket.addEventListener("error", event => {
            console.error("WebSocket Error: " + JSON.stringify(event));
        });
    }
    getName() {
        return "WebSocket";
    }
    isConnected(netTables) {
        return this.connected;
    }
    sendPacket(name, value) {
        if (!this.connected) {
            console.warn("Attempted to send packet '" + name + "' while disconnected!");
            return;
        }
        this.socket.send(msgpack.serialize([
            name,
            value
        ], {multiple: true}));
    }
    close() {
        this.closed = true;
        this.socket.close();
    }
}

var packetProtocols = {
    NetworkTable: () => new NetworkTablePacketProtocol(),
    WebSocket: () => new WebSocketPacketProtocol(5809, 5807, 5806)
};

// Update every 200ms, fast update every 50ms
var netTables = new NetworkTablesHandler(200, 50);

netTables.addPacketListener("WidgetR2D", msg => {
    msg = msgpack.deserialize(Uint8Array.from(atob(msg), b => b.codePointAt(0)), {multiple: true}); // From base64
    var id = msg.shift();
    var widget = widgets.get(id);
    if (widget === undefined) {
        console.warn("Received packet with invalid id '" + id + "'");
        return;
    }
    widget.handlePacket(msg);
});

function refreshConsoleContent() {
    var scrolledToBottom = (e_consoleContent.clientHeight + e_consoleContent.scrollTop >= e_consoleContent.scrollHeight - 4);
    e_consoleContent.value = consoleMsg + consoleCmdSpacing + consoleCmd;
    if (scrolledToBottom) {
        e_consoleContent.scrollTop = e_consoleContent.scrollHeight;
    }
}
netTables.addPacketListener("ConsoleMsg", msg => {
    consoleMsg += msg;
    if (document.visibilityState == "visible") {
        refreshConsoleContent();
    }
});
document.addEventListener("visibilitychange", () => {
    if (document.visibilityState == "visible") {
        refreshConsoleContent();
    }
});

netTables.addPacketListener("LogsResponse", msg => {
    var code = msg.charAt(0);
    var response = msg.substring(1);
    switch (code) {
        case LogCodes.LOAD:
            function sortLogs(files) {
                if (files === 0) {
                    return 0;
                }
                var output = [];
                for (var file in files) {
                    output.push({name: file, value: sortLogs(files[file])});
                }
                output.sort(({name: a}, {name: b}) => (a < b) ? -1 : (a > b) ? 1 : 0);
                return output;
            }
            var temp = document.createElement("div");
            addFolder("", sortLogs(JSON.parse(response)), temp);
            e_tabLogsList.replaceChildren(...temp.children);
            break;
        case LogCodes.VIEW:
            var seperator = response.indexOf("\0");
            var file = response.substring(0, seperator);
            var content = response.substring(seperator + 1);
            e_tabLogsViewerPath.innerText = file;
            e_tabLogsViewerContent.innerText = content;
            e_tabLogsViewerDownload.setAttribute("href", "logs/" + file);
            e_tabLogsViewerActive.checked = true;
            break;
        case LogCodes.DELETE:
            var errorCode = parseInt(response.charAt(0));
            var file = response.substring(1);
            switch (errorCode) {
                case 0: // Success
                    document.getElementById("file_" + htmlIdEncode(file)).remove();
                    if (e_tabLogsViewerPath.innerText == file) {
                        e_tabLogsViewerActive.checked = false;
                    }
                    break;
                case 1: // File in use
                    alert("Cannot delete a log file currently in use: " + file);
                    break;
                case 2: // Error deleting
                    alert("There was an error deleting the log file: " + file);
                    break;
            }
            break;
    }
});

</script>

</body>
</html>